<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/app.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/app.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jslint browser: true*/
/*jslint node: true */
&#x27;use strict&#x27;;
var w = window;
/**
 * current mini seconds
 * @returns {number}
 */
function ms() {
  return Date.now();
};
/**
 * is object empty?
 * @param {object} obj
 * @returns {boolean}
 */
function oie(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * document.getElementById
 * @param {string} id
 * @returns {*}
 */
function d2e(id) {
  return document.getElementById(id);
}

/**
 * Events available
 */
w.SimpleAppStart = &#x27;sta&#x27;;
w.SimpleAppFinish = &#x27;fin&#x27;;
w.SimpleAppWillRender = &#x27;wrd&#x27;;
w.SimpleAppDidRender = &#x27;drd&#x27;;
w.SimpleAppRenderElement = &#x27;rde&#x27;;
w.SimpleAppParseElementData = &#x27;ped&#x27;;
w.SimpleAppStateIsUpdated = &#x27;siu&#x27;;

// lib
String.prototype.hashCode = function () {
  var hash = 0, i, chr, len;
  if (this.length === 0) return hash;
  for (i = 0, len = this.length; i &lt; len; i++) {
    chr = this.charCodeAt(i);
    hash = ((hash &lt;&lt; 5) - hash) + chr;
    hash |= 0;
  }
  return Math.abs(hash);
};
/**
 * string converter
 * @param {object} obj
 * @private
 */
var _s = function (obj) {
  return JSON.stringify(obj);
};
/**
 * obj copier
 * @param {object} obj
 * @private
 */
var _c = function (obj) {
  return JSON.parse(_s(obj));
};
/**
 * app base class
 * @param {string} name
 * @param {object} [cnf={}]
 */
var app;
app = function (name, cnf) {
  this.aName = name;
  // defaults
  name = _s(name).hashCode();
  var prefix = &#x27;_sj_&#x27; + name;
  this.name = name;
  // register app
  w[prefix] = this;
  // local storage key
  this.localStorageKey = prefix + &#x27;_data&#x27;;
  this.container = null;
  // state of the app
  this.state = {};
  this.pState = {};
  /**
   * config default
   * no data, no render
   */
  this.cnf = {
    localStorageWrite: true,
    localStorageRead: true,
    partialRender: true
  };
  // override with external cnf
  if (typeof cnf == &#x27;object&#x27;) {
    for (var k in cnf) {
      this.cnf[k] = cnf[k];
    }
  }

  /**
   * callback registry
   * @type {{els: {}}}
   */
  this.callbacks = {
    sta: {},
    fin: {},
    wrd: {},
    drd: {},
    rde: {},
    ped: {},
    siu: {}
  };

  /**
   * get call by name and type
   * @param {string} type
   * @param {string} [name=null]
   * @returns {*}
   */
  this.getCallback = function (type, name) {
    if (name) {
      if (typeof this.callbacks[type][name] == &#x27;function&#x27;) {
        return this.callbacks[type][name];
      }
    } else {
      return this.callbacks[type];
    }
  };

  /**
   * event triggers
   * @param {string} type
   * @param {string} name
   * @param {function} callback
   */
  this.on = function (type, name, callback) {
    if (typeof this.callbacks[type] == &#x27;object&#x27;) {
      if (typeof callback == &#x27;function&#x27;) {
        this.callbacks[type][name] = callback;
      }
    }
  };
  /**
   * fire events
   * @param {string} type
   * @private
   */
  this._f = function (type) {
    var calls = this.getCallback(type);
    if (typeof calls == &#x27;object&#x27;) {
      for (var k in calls) {
        var call = calls[k];
        if (typeof call == &#x27;function&#x27;) {
          console.log(&#x27;&gt;&gt; calls - &#x27; + k, calls);
          call();
        }
      }
    }
  };
  /**
   * update state of an element
   * @param {*} elementOrName, if value presents and this param is string, this will be a direct update
   * @param {*} [valueOrNull=Null] optional, if the first param is element with value, it will use that
   */
  this.updateState = function (elementOrName, valueOrNull) {
    var name, value, el;
    if (typeof elementOrName == &#x27;string&#x27;) {
      console.log(&#x27;=&gt; update state by name/value&#x27;, elementOrName, valueOrNull);
      name = elementOrName;
      value = valueOrNull;
      this.state[elementOrName] = valueOrNull;
    } else if (typeof elementOrName == &#x27;object&#x27; &amp;&amp; typeof elementOrName.nodeName == &#x27;string&#x27;) {
      console.log(&#x27;=&gt; update state by element&#x27;, elementOrName);
      // must be object
      el = elementOrName;
      var nodeName = el.nodeName;
      var type = el.type;
      if (nodeName == &#x27;SELECT&#x27;) {
        type = &#x27;select&#x27;;
      }
      name = el.name;
      value = el.value;
      switch (type) {
        case &#x27;select&#x27;:
        case &#x27;text&#x27;:
        case &#x27;radio&#x27;:
          this.state[name] = value;
          break;
        case &#x27;checkbox&#x27;:
          if (!this.state[name]) {
            this.state[name] = [];
          }
          if (el.checked &amp;&amp; value.length &gt; 0) {
            if (this.state[name].indexOf(value) &lt; 0) {
              this.state[name].push(value);
            }
          } else {
            var pos = this.state[name].indexOf(value);
            if (pos &gt;= 0) {
              this.state[name].splice(pos, 1);
            }
          }
          break;
        default:
          this.state[name] = value;
          break;
      }
    }
    // save local if necessary
    this.store();
    // notify callback
    this.stateIsUpdated({
      name: name,
      value: value,
      element: el,
      state: this.state
    });
  };
  /**
   * add cr to fire this for your own elements
   * or even directly over-write this function
   * @param {object} data
   */
  this.stateIsUpdated = function (data) {
    // callback by name
    var c = this.getCallback(&#x27;siu&#x27;, data.name);
    if (typeof c == &#x27;function&#x27;) return c(data);
    return data;
  };
  /**
   * template engine
   * @param {string} template
   * @param {object} data
   * @param {boolean} [doNotSkip=true] if true, do not skip the undefined tags
   * @returns {*}
   */
  this.htpl = function (template, data, doNotSkip) {
    doNotSkip = (doNotSkip === true);
    try {
      var output = template;
      for (var n in data) {
        if (n.length &gt; 0) {
          var search = new RegExp(&#x27;{&#x27; + n + &#x27;}&#x27;, &#x27;g&#x27;), rep = data[n];
          output = output.replace(search, rep);
        }
      }
      // clean final output
      if (doNotSkip !== true) output = output.replace(/{[^&lt;&gt;}]+}/ig, &#x27;&#x27;).replace(/{&gt;([^}]+)}/ig, &#x27;{$1}&#x27;);
      return output;
    } catch (e) {
      console.log(&#x27;[Error] html template failure&#x27;, e);
      return &#x27;&#x27;;
    }
  };
  /**
   * store state in local storage
   */
  this.store = function () {
    if (this.cnf.localStorageWrite &amp;&amp; typeof w.localStorage == &#x27;object&#x27;) {
      w.localStorage.setItem(this.localStorageKey, _s(this.state));
    }
  };
  /**
   * retrieve state from local storage
   */
  this.load = function () {
    if (this.cnf.localStorageRead &amp;&amp; typeof w.localStorage == &#x27;object&#x27;) {
      var d = w.localStorage.getItem(this.localStorageKey);
      if (!d) return;
      try {
        this.state = JSON.parse(d);
      } catch (e) {
        console.log(&#x27;[ERROR] Unable to parse state &#x27; + d, e);
      }
    }
  };
  /*------ elements cnf ------*/
  /**
   * template: must have default template, or render will return empty string
   * if &#x27;selected&#x27; template is available, when data fits in the current state, it will use selected state
   * within template, use
   * {__s} for save state calls, e.g. {__s}(&#x27;foo&#x27;, &#x27;bar&#x27;) or {__s}s(this) for elements
   * @type {{main: {}, sub: {}}}
   */
  this.template = {main: {}, sub: {}};
  /**
   * data for elements
   * @type {{main: {}, sub: {}}}
   */
  this.data = {};
  /**
   * previous data
   * @type {{main: {}, sub: {}}}
   */
  this.pData = {};
  /**
   * callback: get element style
   * @param {string} elName
   * @param {object} state
   * @param {object} data
   *
   * @returns {*}
   */
  this.els = function (elName, state, data) {
    // is there style in template setting already?
    if (data._style) {
      console.log(&#x27;&gt;&gt;&gt; Style for &#x27; + elName + &#x27;: &#x27; + data._style);
      return data._style;
    }
    // otherwise, default
    if (state) {
      var s = _s(state);
      var v = _s(data.value);
      return (s.indexOf(v) &gt;= 0) ? &#x27;selected&#x27; : &#x27;default&#x27;;
    }
    return &#x27;default&#x27;;
  };
  /**
   * generate element id
   * @param {string} elName
   * @returns {string}
   */
  this.eId = function (elName) {
    return prefix + &#x27;_el_&#x27; + elName;
  };
  /**
   * callback: custom data parser
   * @param {string} elName
   * @param {object} state
   * @param {object} data
   * @param {string} type
   * @param {int} [subNodeCnt=0] if &gt; 0, it&#x27;s a sub node
   * @returns {{}}
   */
  this.parseElementData = function (elName, state, data, type, subNodeCnt) {
    if (!data) data = {};
    // check if callback is registered
    var c = this.getCallback(&#x27;ped&#x27;, elName);
    if (typeof c == &#x27;function&#x27;) return c(state, data);
    // prepare with attributes, allowed list (+ wildcar &#x27;data-*&#x27;, &#x27;on*&#x27;):
    var d = {}, a = [];
    data.name = elName;

    if (subNodeCnt &gt; 0) {
      if (type != &#x27;select&#x27;) {
        if (!data.id) data.id = this.eId(elName + &#x27;_&#x27; + subNodeCnt);
      }
    } else {
      if (!data.id) data.id = this.eId(elName);
    }
    // generate on[change] by type
    var act = prefix + &#x27;.updateState(this)&#x27;;
    if (!subNodeCnt) {
      switch (type) {
        case &#x27;select&#x27;:
          data.onchange = act;
          break;
        case &#x27;input&#x27;:
          data.onkeyup = act;
          if (!data.value) {
            data.value = state;
          }
          break;
        default:
          if (type) data.onclick = act;
          break;
      }
    }
    d.selectState = &#x27;&#x27;;
    // select
    if (subNodeCnt &gt; 0 &amp;&amp; _s(state).indexOf(_s(data.value)) &gt;= 0) {
      console.log(&#x27;check select: &#x27; + state + &#x27; &lt;&gt; &#x27; + data.value);
      if (type == &#x27;select&#x27;) {
        data.selected = &#x27;selected&#x27;;
        d.selectState = &#x27;selected=&quot;selected&quot;&#x27;;
      }
      if (type == &#x27;checkbox&#x27; || type == &#x27;radio&#x27;) {
        data.checked = &#x27;checked&#x27;;
        d.selectState = &#x27;checked=&quot;checked&quot;&#x27;;
      }
    }

    for (var i in data) {
      d[i] = data[i];
      // rule: all custom variables must start with _, others will be treated as attributes
      if (i.indexOf(&#x27;_&#x27;) &lt; 0) {
        a.push(i + &#x27;=&quot;&#x27; + data[i] + &#x27;&quot;&#x27;);
      }
    }
    d.attr = a.join(&#x27; &#x27;);
    d.action = act;
    if (elName == &#x27;welcomeStyle&#x27;) console.log(&#x27;&gt;&gt;&gt; parseElementData&#x27;, d);
    return d;
  };
  /**
   * get node by elementName
   * @param {string} elName
   * @returns {Element}
   */
  this.node = function (elName) {
    return d2e(this.eId(elName));
  };
  /*------ render ------*/
  /**
   * main template style
   * @type {string}
   */
  this.style = &#x27;default&#x27;;
  /**
   * render entire app
   * @param {boolean} [full=false] if true, force a complete render
   *
   * RUN LOGIC:
   * 1. data changed for el?
   *  1.1 is it a wrapper type?
   *    YES: go to 1.2
   *    NO:
   *      1.1.0 is the vNode non-existent?
   *        YES: new vNode()
   *        NO: is the template style changed?
   *          YES: new vNode
   *          NO: go to next
   *      1.1.1 is the data empty?
   *        YES: vNode.remove()
   *        NO: vNode.updateHTML()
   *  1.2 yes it&#x27;s a wrapper
   *    1.2.0 is vNode non-existent?
   *      YES: new vNode plus children
   *      NO: go to next
   *    1.2.1 loop thru children:
   *      with each child:
   *      new data count &gt; old data count?
   *      YES:
   *        vNode exists?
   *          YES: vNode.updateHTML() - no need to remove anything (so order doesn&#x27;t really matter)
   *          NO: new vNode, vNode.right(parent);
   *     NO:
   *        count vNode and remove ones that are not in vNode.remove()
   */
  this.render = function (full) {
    var stime = ms();
    console.log(&#x27;=&gt; Start Rendering &#x27; + this.aName);
    this._f(&#x27;wrd&#x27;);
    if (!this.container) throw new Error(&#x27;Invalid container specified&#x27;);
    // findout main template details
    var t = this.template.main[this.style];
    var d = {};
    if (!t) throw new Error(&#x27;Invalid master template for style: &#x27; + this.style);
    // logic: force render clears prevData, and that, is that.
    if (full === true) this.pData = {};
    // verify data presence
    if (oie(this.data) || _s(this.pData) == _s(this.data)) {
      // nothing to render - data is empty, or data is unchanged
      console.log(&#x27;No data found, nothing will be rendered&#x27;);
      return;
    }
    // set control: force render
    var forceRender = oie(this.pData);
    // start loop and render (and pass forceRender if necessary)
    for (var n in this.template.sub) {
      console.log(&#x27;=&gt; Render sub: &#x27; + n);
      var tmp = this.renderElement(n, forceRender);
      if (tmp) d[n] = tmp;
    }
    if (forceRender || !oie(d)) {
      this.container.innerHTML = this.htpl(t, d);
    }
    // at the end, run callback and set state/data
    // make previous state the same as current now
    this.pState = _c(this.state);
    // also make previous data the same as current data in elements
    this.pData = _c(this.data);
    // callback
    this._f(&#x27;drd&#x27;);
    console.log(&#x27;=&gt; Finish Rendering in &#x27; + (ms() - stime) + &#x27; ms&#x27;);
  };
  /**
   * render single element
   * @param {string} elName
   * @param {boolean} forceRender if true, for render without using node
   * @returns {*}
   */
  this.renderElement = function (elName, forceRender) {
    forceRender = (forceRender === true);
    // figure out the type (from template._type)
    var data = this.data[elName] || {}, state = this.state[elName] || &#x27;&#x27;, output = &#x27;&#x27;;

    if (typeof this.template.sub[elName] != &#x27;object&#x27; || oie(data)) {
      console.log(&#x27;[Warning] No element template found or empty data for &#x27; + elName);
      // decide whether to remove it from parent...
      if (this.cnf.partialRender &amp;&amp; !forceRender) {
        var existingNode = this.node(elName);
        if (existingNode) {
          console.log(&#x27;No data found, remove node&#x27;);
          existingNode.parentNode.removeChild(existingNode);
          return false;
        }
      }

      return &#x27;&#x27;;
    }
    // if custom render function exists, use it.
    var c = this.getCallback(&#x27;rde&#x27;, elName);
    if (typeof c == &#x27;function&#x27;) return c(state, data);
    // is data changed? if not, do not render (when partial)
    if (_s(this.data[elName]) == _s(this.pData[elName])) {
      return false;
    }

    // does it have a wrapper? if not, render as a single element
    var t = this.template.sub[elName], type = t._type;
    var self = this;
    if (t._wrapper) {
      // logic: same or less -&gt; vNode.updateHTML || vNode.remove(), more? vNode.right();
      if (!data.wrapper) data.wrapper = {};
      // render as wrapper
      var wAttr = this.parseElementData(elName, state, data.wrapper, t._type), elData = data.element || [], m = 0;
      // check prevData to ensure rendering take advantage of vNode or innerHTML
      var tmpData = this.pData[elName];
      var prevElementData = [];
      if (!tmpData) {
        // render all
        forceRender = true;
      } else {
        prevElementData = _c(tmpData.element);
      }
      // loop and remove
      var nodeParent = false;
      elData.map(function (item) {
        // start rendering
        m++;
        var di = _c(item);
        var si = self.els(elName, state, di);
        var ti = self.template.sub[elName][si];
        var datai = self.parseElementData(elName, state, di, t._type, m);
        if (!ti) ti = self.template.sub[elName][&#x27;default&#x27;];
        // is it select type?
        if (t._type == &#x27;select&#x27;) {
          // just render and go
          output += self.htpl(ti, datai);
          return;
        }

        // retreive node
        // 1st. if not partial, or force render, keep adding to it
        if (self.cnf.partialRender &amp;&amp; !forceRender) {
          // logic - data less or more?
          var n = m - 1, before = self.pData[elName].element[n], after = self.data[elName].element[n], src = null;
          if (_s(before) == _s(after)) {
            // nothing is changed, do not render
            return;
          }
          var node = self.node(elName + &#x27;_&#x27; + m);
          if (!nodeParent) nodeParent = node.parentNode;
          // partial render here
          src = self.htpl(ti, datai);
          var vn;
          if (nodeParent) {
            if (node) {
              if (src) {
                vn = new vNode(src, nodeParent);
                vn.replace(node);
              }
            } else {
              // add some more to it
              if (nodeParent) {
                vn = new vNode(src, nodeParent);
                vn.right();
              } else {
                console.log(&#x27;[ERROR] unable to find node parent, can not append&#x27;);
              }
            }
          }

        } else {
          // render as a whole (select, or force render, or initial render)
          output += self.htpl(ti, datai);
        }
      });
      // removal when 1. nodeParent, 2. elPData exists
      if (nodeParent &amp;&amp; prevElementData.length &gt; elData.length) {
        prevElementData.map(function (el, item) {
            if (item &gt;= m) {
              var node = self.node(elName + &#x27;_&#x27; + item);
              // remove childnode
              console.log(&#x27;Remove child: &#x27; + item);
              if (node) nodeParent.removeChild(node);
            }
          }
        );
      }

      if (typeof output == &#x27;string&#x27; &amp;&amp; output.length &gt; 1) {
        output = self.htpl(t._wrapper[0], wAttr) + output + t._wrapper[1];
      } else {
        // stop here as it&#x27;s replaced
        console.log(&#x27;=&gt; Render Element [&#x27; + elName + &#x27;]: using DOM.&#x27;);
        return false;
      }
    } else {
      // single tag element - it should never be empty really - but lets work on it
      console.log(&#x27;&gt;&gt;&gt; render [&#x27; + elName + &#x27;] as a whole&#x27;);
      var si = this.els(elName, state, data);
      var ti = this.template.sub[elName][si];
      var datai = this.parseElementData(elName, state, data, t._type);
      if (!ti) ti = this.template.sub[elName][&#x27;default&#x27;];
      output = this.htpl(ti, datai);
    }
    // logic: if node exists, replace html, otherwise, return it
    // verify if we have sibling enabled - so we can append it
    if (this.template.sub[elName]._sibling) {
      // append sibling
      var sibling = this.node(this.template.sub[elName]._sibling);
      if (sibling) {
        var newNode = new vNode(output, sibling.parentNode);
        newNode.right();
        return false;
      }
    }
    // 2nd - it must be partial and if node doesn&#x27;t exists, return itself, otherwise, update by replacing node
    if (!forceRender &amp;&amp; this.cnf.partialRender === true &amp;&amp; output) {
      var node = this.node(elName), nn = null;
      // replace
      if (node) {
        nn = new vNode(output);
        nn.replace(node);
        return false;
      }
    }
    // finally, default
    return output;
  };
  /*------ init ------*/
  /**
   * init app
   * @param {string} container
   * @param {boolean} [autoRender=true]
   */
  this.init = function (container, autoRender) {
    if (container) this.container = container;
    // load state from local storage if applicable
    this.load();
    if (autoRender === false) return;
    // next, render
    this._f(&#x27;sta&#x27;);
    this.render();
    this._f(&#x27;fin&#x27;);
  };

  /**
   * export to query string
   * @returns {string}
   */
  this.toQuerystring = function () {
    var qs = [];
    for (var n in this.state) {
      var v = this.state[n];
      if (v) {
        qs.push(n + &#x27;=&#x27; + v);
      }
    }
    return qs.join(&#x27;&amp;&#x27;);
  };
  /**
   * apis for fast access over data
   * @param {string} elName
   * @param {int} [nodePosition=Null]
   * @returns {*}
   */
  this.d = function (elName, nodePosition) {
    if (!nodePosition) {
      return this.data[elName];
    }
    if (typeof this.data[elName].element == &#x27;object&#x27; &amp;&amp;
      this.data[elName].element[nodePosition]) {
      return this.data[elName].element[nodePosition];
    }
  };
};
/*------ export ------*/
var z = {};
/**
 * THIS IS THE MAIN ENTRY POINT
 *
 * create / retrieve a single app
 *
 * e.g.
 * &#x60;&#x60;&#x60;
 * var app = SimpleApp(&#x27;my-app&#x27;);
 * app.init(document.getElementById(&#x27;app_container&#x27;), true);
 * &#x60;&#x60;&#x60;
 * @param {string} name
 * @param {object} [config={}] | note: this is the system config
 * @returns {SimpleApp}
 */
w.SimpleApp = function (name, config) {
  if (!z[name]) z[name] = new app(name, config);
  return z[name];
};
// nodejs compatible
if (typeof exports != &#x27;undefined&#x27;) {
  exports.SimpleApp = w.SimpleApp;
}
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
